# kmv/app/viewer.py
"""
`Viewer` – the *only* class your RL / control loop talks to.

Responsibilities
----------------
* Serialise a compiled `mjModel` to a temp .mjb file.
* Allocate one shared-memory ring per data stream (qpos, qvel, …).
* Create a control pipe and a bounded metrics queue.
* Spawn the GUI process (`worker.entrypoint.run_worker`) with the above handles.
* Provide ergonomic push / poll helpers for the parent process.
"""

from __future__ import annotations

import tempfile
from pathlib import Path
from types import SimpleNamespace
from typing import Any, Mapping, Sequence

import mujoco
import numpy as np

import multiprocessing as mp

from kmv.core import types as ct
from kmv.core.buffer import RingBuffer          # used for off-screen mode
from kmv.core import schema                     # declares default streams
from kmv.ipc.state import SharedArrayRing
from kmv.ipc.control import ControlPipe, make_metrics_queue
from kmv.worker.entrypoint import run_worker


# --------------------------------------------------------------------------- #
#  Helpers
# --------------------------------------------------------------------------- #

def _compile_model_to_mjb(model: mujoco.MjModel) -> Path:
    """Write `model` to a temp .mjb file and return the path."""
    tmp = tempfile.NamedTemporaryFile(suffix=".mjb", delete=False)
    mujoco.mj_saveModel(model, tmp.name, None)
    tmp.close()
    return Path(tmp.name)


def _build_shm_rings(model: mujoco.MjModel) -> dict[str, SharedArrayRing]:
    """Create rings for every stream defined in `core.schema`."""
    rings: dict[str, SharedArrayRing] = {}
    for name, shape in schema.default_streams(model).items():
        rings[name] = SharedArrayRing(create=True, shape=shape)
    return rings


# --------------------------------------------------------------------------- #
#  Public class
# --------------------------------------------------------------------------- #

class Viewer:
    """
    High-level out-of-process viewer.

    Usage
    -----
    >>> viewer = Viewer(mj_model)
    >>> while training:
    ...     mujoco.mj_step(model, data)
    ...     viewer.push_state(data.qpos, data.qvel, sim_time=data.time)
    ...     forces = viewer.poll_forces()
    """

    # ------------------------------------------------------------------ #

    def __init__(
        self,
        mj_model: mujoco.MjModel,
        *,
        mode: ct.RenderMode = "window",
        **view_opts,
    ) -> None:
        if mode not in ("window", "offscreen"):
            raise ValueError(f"unknown render mode {mode!r}")

        self._mode = mode
        self._tmp_mjb_path = _compile_model_to_mjb(mj_model)

        # ---------- shared memory for bulk state ----------------------- #
        self._rings = _build_shm_rings(mj_model)
        shm_cfg = {
            name: {"name": ring.name, "shape": ring.shape}
            for name, ring in self._rings.items()
        }

        # ---------- control & metrics IPC ------------------------------ #
        self._ctrl = ControlPipe()
        ctx        = mp.get_context("spawn")
        self._metrics_q = make_metrics_queue()

        # ---------- spawn GUI process ---------------------------------- #
        self._proc = ctx.Process(
            target=run_worker,
            args=(
                str(self._tmp_mjb_path),
                shm_cfg,
                self._ctrl.sender(),       # write-only end to child
                self._metrics_q,
                view_opts,                 # dict with width, shadow…
            ),
            daemon=True,
        )
        self._proc.start()

    # ------------------------------------------------------------------ #
    #  Producer helpers – called from sim loop
    # ------------------------------------------------------------------ #

    def push_state(
        self,
        qpos: np.ndarray,
        qvel: np.ndarray,
        *,
        sim_time: float | int = 0.0,
        xfrc_applied: np.ndarray | None = None,
    ) -> None:
        """Copy MuJoCo state into shared rings (qpos / qvel)."""
        self._rings["qpos"].push(qpos)
        self._rings["qvel"].push(qvel)
        # Append scalar sim_time into qvel ring’s last slot (compact trick)
        # Alternatively create a dedicated ring; choose what you prefer.
        # For now we skip sim_time — worker uses its own clock.

        if xfrc_applied is not None:
            # If you later add a ring for forces, push here
            pass

    def push_scalars(self, scalars: Mapping[str, float]) -> None:
        """Send telemetry metrics to the GUI."""
        self._metrics_q.put(dict(scalars))

    # ------------------------------------------------------------------ #
    #  Consumer helper – drag forces coming back
    # ------------------------------------------------------------------ #

    def poll_forces(self) -> np.ndarray | None:
        """
        Non-blocking.  Returns the latest ``xfrc_applied`` array generated by
        mouse interaction in the GUI, or ``None`` if nothing new.
        """
        out = None
        while self._ctrl.poll():
            tag, payload = self._ctrl.recv()
            if tag == "forces":
                out = payload
            elif tag == "shutdown":
                self.close()
        return out

    # ------------------------------------------------------------------ #
    #  Shutdown
    # ------------------------------------------------------------------ #

    def close(self) -> None:
        """Terminate the GUI process and unlink shared memory."""
        try:
            if self._proc.is_alive():
                self._proc.terminate()
                self._proc.join(timeout=1.0)
        finally:
            for ring in self._rings.values():
                ring.close()
                ring.unlink()
            self._ctrl.close()
            self._tmp_mjb_path.unlink(missing_ok=True)
