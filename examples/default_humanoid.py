#!/usr/bin/env python3
"""
Sanity-check for the new *out-of-process* viewer.

Runs the MuJoCo humanoid for a while and streams qpos/qvel to
`RemoteViewer`.  The GUI should stay ~60 FPS even if we sleep.
"""

import time
import tempfile
from pathlib import Path
import mujoco
import numpy as np
import colorlogging
import logging

from kmv.app.remote import RemoteViewer          # ← NEW viewer handle

logger = logging.getLogger(__name__)


def main() -> None:
    colorlogging.configure()
    xml_path = Path(__file__).parent.parent / "tests" / "assets" / "humanoid.xml"
    logger.info("Loading model: %s", xml_path)

    physics_dt   = 0.002
    model = mujoco.MjModel.from_xml_path(str(xml_path))
    model.opt.timestep = physics_dt
    data  = mujoco.MjData(model)

    # Save model as temporary MJB binary file for the viewer
    with tempfile.NamedTemporaryFile(mode='wb', suffix='.mjb', delete=False) as f:
        mujoco.mj_saveModel(model, f.name, None)
        mjb_path = f.name

    viewer = RemoteViewer(model, mjb_path) # starts its own process

    # camera defaults (same as before)
    viewer.push_frame(qpos=data.qpos.copy(), qvel=data.qvel.copy())  # send one frame so GUI opens
    logger.info("Viewer launched, hit Ctrl-C to quit")

    counter = 0
    frames_sent = 0
    wall_t0 = time.time()

    # ── add a buffer so the force is applied in the next step ─────────────
    pending_xfrc = None

    try:
        while True:
            counter += 1

            # 1) apply any force collected in the previous GUI frame
            if pending_xfrc is not None:
                data.xfrc_applied[:] = pending_xfrc
                pending_xfrc = None            # one-shot; MuJoCo will clear after step

            # 2) advance physics ------------------------------------------------
            mujoco.mj_step(model, data)

            # 3) send frame to the viewer --------------------------------------
            viewer.push_frame(
                qpos=data.qpos.copy(),
                qvel=data.qvel.copy(),
                sim_time=float(data.time),
            )

            # 4) pull new forces generated by mouse drag -----------------------
            new_xfrc = viewer.poll_forces()
            if new_xfrc is not None:
                pending_xfrc = new_xfrc        # will be applied at top of loop

            # 5) live telemetry (unchanged) ------------------------------------
            frames_sent += 1
            wall_time_elapsed = time.time() - wall_t0
            real_time_factor = float(data.time) / (wall_time_elapsed + 1e-9)
            viewer.push_metrics(
                {
                    "sim t":        float(data.time),
                    "real t":       wall_time_elapsed,
                    "iters":        counter,
                    "frames sent":  frames_sent,
                    "× real-time":  real_time_factor,
                }
            )

            time.sleep(0.001)

    except KeyboardInterrupt:
        print("\nExiting.")

    finally:
        viewer.close()


if __name__ == "__main__":
    main()
