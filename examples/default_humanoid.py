"""
Sanity-check for the new *out-of-process* viewer.

Runs MuJoCo's humanoid for a while and streams qpos/qvel + live telemetry
to `kmv.app.viewer.Viewer`.  The GUI should stay ~60 FPS even if we sleep.
"""

from __future__ import annotations

import time
from pathlib import Path
import logging

import mujoco
import numpy as np
import colorlogging

from kmv.app.viewer import QtViewer

logger = logging.getLogger(__name__)


def main() -> None:
    colorlogging.configure()
    xml_path = Path(__file__).parent.parent / "tests" / "assets" / "humanoid.xml"
    logger.info("Loading model: %s", xml_path)

    physics_dt = 0.02
    model = mujoco.MjModel.from_xml_path(str(xml_path))
    model.opt.timestep = physics_dt
    data  = mujoco.MjData(model)

    viewer = QtViewer(model, enable_plots=True)

    # push one frame so GUI window pops immediately
    viewer.push_state(data.qpos, data.qvel, sim_time=data.time)

    logger.info("Viewer launched — Ctrl-drag to perturb, hit Ctrl-C to quit")

    sim_it   = 0
    t0_wall  = time.perf_counter()
    dt       = physics_dt
    pending_xfrc = None

    try:
        while True:
            sim_it += 1

            # (1) external forces from GUI
            if pending_xfrc is not None:
                data.xfrc_applied[:] = pending_xfrc
                pending_xfrc = None

            # (2) physics step
            mujoco.mj_step(model, data)

            # (3) stream state to viewer
            viewer.push_state(data.qpos, data.qvel, sim_time=data.time)

            # (4) pull forces generated by mouse drag
            new_force = viewer.drain_control_pipe()
            if new_force is not None:
                pending_xfrc = new_force

            # (5) live telemetry
            wall_elapsed = time.perf_counter() - t0_wall
            realtime_x   = float(data.time) / (wall_elapsed + 1e-9)
            viewer.push_table_metrics(
                {
                    "sim t":        float(data.time),
                    "wall t":       wall_elapsed,
                    "iters":        sim_it,
                    "× real-time":  realtime_x,
                }
            )

            # first three qpos/qvel values as live plot streams
            viewer.push_plot_metrics(group="Physics", scalars=
                {
                    "qpos0": float(data.qpos[0]),
                    "qpos1": float(data.qpos[1]),
                    "qpos2": float(data.qpos[2]),
                    "qvel0": float(data.qvel[0]),
                    "qvel1": float(data.qvel[1]),
                    "qvel2": float(data.qvel[2]),
                }
            )

            # (6) sleep so that sim-time == wall-time
            # target wall-time for *next* physics step:
            target_wall = t0_wall + (data.time + dt)
            now         = time.perf_counter()
            sleep_s     = target_wall - now
            if sleep_s > 0:
                time.sleep(sleep_s)

    except KeyboardInterrupt:
        print("\nExiting simulation loop…")

    finally:
        viewer.close()


if __name__ == "__main__":
    main()
